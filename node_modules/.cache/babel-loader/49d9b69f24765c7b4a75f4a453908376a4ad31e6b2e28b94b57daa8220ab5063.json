{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/home/joaob/Projetos-Portifolio/Trybe-Projeto-Trivia/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar htmlparser = require('htmlparser2');\nvar escapeStringRegexp = require('escape-string-regexp');\nvar _require = require('is-plain-object'),\n  isPlainObject = _require.isPlainObject;\nvar deepmerge = require('deepmerge');\nvar parseSrcset = require('parse-srcset');\nvar _require2 = require('postcss'),\n  postcssParse = _require2.parse;\n// Tags that can conceivably represent stand-alone media.\nvar mediaTags = ['img', 'audio', 'video', 'picture', 'svg', 'object', 'map', 'iframe', 'embed'];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nvar vulnerableTags = ['script', 'style'];\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  var n = [];\n  each(a, function (v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\nfunction isEmptyObject(obj) {\n  for (var key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function (part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n    return part.url + (part.w ? \" \".concat(part.w, \"w\") : '') + (part.h ? \" \".concat(part.h, \"h\") : '') + (part.d ? \" \".concat(part.d, \"x\") : '');\n  }).join(', ');\n}\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nvar VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  if (html == null) {\n    return '';\n  }\n  if (typeof html === 'number') {\n    html = html.toString();\n  }\n  var result = '';\n  // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n  var tempResult = '';\n  function Frame(tag, attribs) {\n    var that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n    this.mediaChildren = [];\n    this.updateParentNodeText = function () {\n      if (stack.length) {\n        var parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n    this.updateParentNodeMediaChildren = function () {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        var parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n\n  // vulnerableTags\n  vulnerableTags.forEach(function (tag) {\n    if (options.allowedTags !== false && (options.allowedTags || []).indexOf(tag) > -1 && !options.allowVulnerableTags) {\n      console.warn(\"\\n\\n\\u26A0\\uFE0F Your `allowedTags` option includes, `\".concat(tag, \"`, which is inherently\\nvulnerable to XSS attacks. Please remove it from `allowedTags`.\\nOr, to disable this warning, add the `allowVulnerableTags` option\\nand ensure you are accounting for this risk.\\n\\n\"));\n    }\n  });\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  var nonTextTagsArray = options.nonTextTags || ['script', 'style', 'textarea', 'option'];\n  var allowedAttributesMap;\n  var allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function (attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      var globRegex = [];\n      attributes.forEach(function (obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n  var allowedClassesMap = {};\n  var allowedClassesGlobMap = {};\n  var allowedClassesRegexMap = {};\n  each(options.allowedClasses, function (classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n    allowedClassesMap[tag] = [];\n    allowedClassesRegexMap[tag] = [];\n    var globRegex = [];\n    classes.forEach(function (obj) {\n      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n        globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n      } else if (obj instanceof RegExp) {\n        allowedClassesRegexMap[tag].push(obj);\n      } else {\n        allowedClassesMap[tag].push(obj);\n      }\n    });\n    if (globRegex.length) {\n      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    }\n  });\n  var transformTagsMap = {};\n  var transformTagsAll;\n  each(options.transformTags, function (transform, tag) {\n    var transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n  var depth;\n  var stack;\n  var skipMap;\n  var transformMap;\n  var skipText;\n  var skipTextDepth;\n  var addedText = false;\n  initializeState();\n  var parser = new htmlparser.Parser({\n    onopentag: function onopentag(name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      var frame = new Frame(name, attribs);\n      stack.push(frame);\n      var skip = false;\n      var hasText = !!frame.text;\n      var transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n        frame.attribs = attribs = transformedTag.attribs;\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (options.allowedTags !== false && (options.allowedTags || []).indexOf(name) === -1 || options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {\n        skip = true;\n        skipMap[depth] = true;\n        if (options.disallowedTagsMode === 'discard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard') {\n          // We want the contents but not this tag\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      result += '<' + name;\n      if (name === 'script') {\n        if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n          frame.innerText = '';\n        }\n      }\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function (value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          var passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1 || allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a) || allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a)) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            var _iterator = _createForOfIteratorHelper(allowedAttributesMap[name]),\n              _step;\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var o = _step.value;\n                if (isPlainObject(o) && o.name && o.name === a) {\n                  passedAllowedAttributesMapCheck = true;\n                  var newValue = '';\n                  if (o.multiple === true) {\n                    // verify the values that are allowed\n                    var splitStrArray = value.split(' ');\n                    var _iterator2 = _createForOfIteratorHelper(splitStrArray),\n                      _step2;\n                    try {\n                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                        var s = _step2.value;\n                        if (o.values.indexOf(s) !== -1) {\n                          if (newValue === '') {\n                            newValue = s;\n                          } else {\n                            newValue += ' ' + s;\n                          }\n                        }\n                      }\n                    } catch (err) {\n                      _iterator2.e(err);\n                    } finally {\n                      _iterator2.f();\n                    }\n                  } else if (o.values.indexOf(value) >= 0) {\n                    // verified an allowed value matches the entire attribute value\n                    newValue = value;\n                  }\n                  value = newValue;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (name === 'script' && a === 'src') {\n              var allowed = true;\n              try {\n                var parsed = parseUrl(value);\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                  var allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  var allowedDomain = (options.allowedScriptDomains || []).find(function (domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(\".\".concat(domain));\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (name === 'iframe' && a === 'src') {\n              var _allowed = true;\n              try {\n                var _parsed = parseUrl(value);\n                if (_parsed.isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  _allowed = has(options, 'allowIframeRelativeUrls') ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  var _allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === _parsed.url.hostname;\n                  });\n                  var _allowedDomain = (options.allowedIframeDomains || []).find(function (domain) {\n                    return _parsed.url.hostname === domain || _parsed.url.hostname.endsWith(\".\".concat(domain));\n                  });\n                  _allowed = _allowedHostname || _allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                _allowed = false;\n              }\n              if (!_allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                var _parsed2 = parseSrcset(value);\n                _parsed2.forEach(function (value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                _parsed2 = filter(_parsed2, function (v) {\n                  return !v.evil;\n                });\n                if (!_parsed2.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(_parsed2, function (v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              var allowedSpecificClasses = allowedClassesMap[name];\n              var allowedWildcardClasses = allowedClassesMap['*'];\n              var allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              var allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n              var allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              var allowedClassesGlobs = [allowedSpecificClassesGlob, allowedWildcardClassesGlob].concat(allowedSpecificClassesRegex).filter(function (t) {\n                return t;\n              });\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              if (options.parseStyleAttributes) {\n                try {\n                  var abstractSyntaxTree = postcssParse(name + ' {' + value + '}');\n                  var filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n                  value = stringifyStyleAttributes(filteredAST);\n                  if (value.length === 0) {\n                    delete frame.attribs[a];\n                    return;\n                  }\n                } catch (e) {\n                  console.warn('Failed to parse \"' + name + ' {' + value + '}' + '\", If you\\'re running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547');\n                  delete frame.attribs[a];\n                  return;\n                }\n              } else if (options.allowedStyles) {\n                throw new Error('allowedStyles option cannot be used together with parseStyleAttributes: false.');\n              }\n            }\n            result += ' ' + a;\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function ontext(text) {\n      if (skipText) {\n        return;\n      }\n      var lastFrame = stack[stack.length - 1];\n      var tag;\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n      if (options.disallowedTagsMode === 'discard' && (tag === 'script' || tag === 'style')) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        var escaped = escapeHtml(text, false);\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        var frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function onclosetag(name) {\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n      var frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n      if (frame.tag !== name) {\n        // Another case of bad markup.\n        // Push to stack, so that it will be used in future closing tags.\n        stack.push(frame);\n        return;\n      }\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      var skip = skipMap[depth];\n      if (skip) {\n        delete skipMap[depth];\n        if (options.disallowedTagsMode === 'discard') {\n          frame.updateParentNodeText();\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n        return;\n      }\n      result += '</' + name + '>';\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n      addedText = false;\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n  return result;\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n  function escapeHtml(s, quote) {\n    if (typeof s !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n    .replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n    return s;\n  }\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    while (true) {\n      var firstIndex = href.indexOf('<!--');\n      if (firstIndex === -1) {\n        break;\n      }\n      var lastIndex = href.indexOf('-->', firstIndex + 4);\n      if (lastIndex === -1) {\n        break;\n      }\n      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);\n    }\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n    var matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    var scheme = matches[1].toLowerCase();\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n  function parseUrl(value) {\n    value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n    if (value.startsWith('relative:')) {\n      // An attempt to exploit our workaround for base URLs being\n      // mandatory for relative URL validation in the WHATWG\n      // URL parser, reject it\n      throw new Error('relative: exploit attempt');\n    }\n    // naughtyHref is in charge of whether protocol relative URLs\n    // are cool. Here we are concerned just with allowed hostnames and\n    // whether to allow relative URLs.\n    //\n    // Build a placeholder \"base URL\" against which any reasonable\n    // relative URL may be parsed successfully\n    var base = 'relative://relative-site';\n    for (var i = 0; i < 100; i++) {\n      base += \"/\".concat(i);\n    }\n    var parsed = new URL(value, base);\n    var isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n    return {\n      isRelativeUrl: isRelativeUrl,\n      url: parsed\n    };\n  }\n  /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n    var astRules = abstractSyntaxTree.nodes[0];\n    var selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(allowedStyles[astRules.selector], allowedStyles['*']);\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n    if (selectedRule) {\n      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n    return abstractSyntaxTree;\n  }\n\n  /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes.reduce(function (extractedAttributes, attrObject) {\n      extractedAttributes.push(\"\".concat(attrObject.prop, \":\").concat(attrObject.value).concat(attrObject.important ? ' !important' : ''));\n      return extractedAttributes;\n    }, []).join(';');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is allowlisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        var matchesRegex = selectedRule[attributeObject.prop].some(function (regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function (clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function (glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nvar htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [\n  // Sections derived from MDN element categories and limited to the more\n  // benign categories.\n  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n  // Content sectioning\n  'address', 'article', 'aside', 'footer', 'header', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup', 'main', 'nav', 'section',\n  // Text content\n  'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure', 'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',\n  // Inline text semantics\n  'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'rb', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',\n  // Table content\n  'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr'],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: ['href', 'name', 'target'],\n    // We don't currently allow img itself by default, but\n    // these attributes would make sense if we did.\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height', 'loading']\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: ['img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta'],\n  // URL schemes we permit\n  allowedSchemes: ['http', 'https', 'ftp', 'mailto', 'tel'],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: ['href', 'src', 'cite'],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false,\n  parseStyleAttributes: true\n};\nsanitizeHtml.simpleTransform = function (newTagName, newAttribs, merge) {\n  merge = merge === undefined ? true : merge;\n  newAttribs = newAttribs || {};\n  return function (tagName, attribs) {\n    var attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};","map":{"version":3,"names":["htmlparser","require","escapeStringRegexp","isPlainObject","deepmerge","parseSrcset","postcssParse","parse","mediaTags","vulnerableTags","each","obj","cb","Object","keys","forEach","key","has","hasOwnProperty","call","filter","a","n","v","push","isEmptyObject","stringifySrcset","parsedSrcset","map","part","url","Error","w","h","d","join","module","exports","sanitizeHtml","VALID_HTML_ATTRIBUTE_NAME","html","options","_recursing","toString","result","tempResult","Frame","tag","attribs","that","tagPosition","length","text","mediaChildren","updateParentNodeText","stack","parentFrame","updateParentNodeMediaChildren","includes","assign","defaults","parser","htmlParserDefaults","allowedTags","indexOf","allowVulnerableTags","console","warn","nonTextTagsArray","nonTextTags","allowedAttributesMap","allowedAttributesGlobMap","allowedAttributes","attributes","globRegex","replace","RegExp","allowedClassesMap","allowedClassesGlobMap","allowedClassesRegexMap","allowedClasses","classes","transformTagsMap","transformTagsAll","transformTags","transform","transFun","simpleTransform","depth","skipMap","transformMap","skipText","skipTextDepth","addedText","initializeState","Parser","onopentag","name","enforceHtmlBoundary","frame","skip","hasText","transformedTag","undefined","innerText","tagName","disallowedTagsMode","nestingLimit","allowedScriptHostnames","allowedScriptDomains","value","test","passedAllowedAttributesMapCheck","o","newValue","multiple","splitStrArray","split","s","values","allowedSchemesAppliedToAttributes","naughtyHref","allowed","parsed","parseUrl","allowedHostname","find","hostname","allowedDomain","domain","endsWith","e","isRelativeUrl","allowIframeRelativeUrls","allowedIframeHostnames","allowedIframeDomains","evil","allowedSpecificClasses","allowedWildcardClasses","allowedSpecificClassesGlob","allowedSpecificClassesRegex","allowedWildcardClassesGlob","allowedClassesGlobs","concat","t","filterClasses","parseStyleAttributes","abstractSyntaxTree","filteredAST","filterCss","allowedStyles","stringifyStyleAttributes","escapeHtml","selfClosing","textFilter","ontext","lastFrame","escaped","onclosetag","pop","exclusiveFilter","substr","write","end","quote","decodeEntities","href","firstIndex","lastIndex","substring","matches","match","allowProtocolRelative","scheme","toLowerCase","allowedSchemesByTag","allowedSchemes","startsWith","base","i","URL","protocol","astRules","nodes","selectedRule","selector","reduce","filterDeclarations","extractedAttributes","attrObject","prop","important","allowedDeclarationsList","attributeObject","matchesRegex","some","regularExpression","allowedGlobs","clss","glob","img","newTagName","newAttribs","merge","attrib"],"sources":["/home/joaob/Projetos-Portifolio/Trybe-Projeto-Trivia/node_modules/sanitize-html/index.js"],"sourcesContent":["const htmlparser = require('htmlparser2');\nconst escapeStringRegexp = require('escape-string-regexp');\nconst { isPlainObject } = require('is-plain-object');\nconst deepmerge = require('deepmerge');\nconst parseSrcset = require('parse-srcset');\nconst { parse: postcssParse } = require('postcss');\n// Tags that can conceivably represent stand-alone media.\nconst mediaTags = [\n  'img', 'audio', 'video', 'picture', 'svg',\n  'object', 'map', 'iframe', 'embed'\n];\n// Tags that are inherently vulnerable to being used in XSS attacks.\nconst vulnerableTags = [ 'script', 'style' ];\n\nfunction each(obj, cb) {\n  if (obj) {\n    Object.keys(obj).forEach(function (key) {\n      cb(obj[key], key);\n    });\n  }\n}\n\n// Avoid false positives with .__proto__, .hasOwnProperty, etc.\nfunction has(obj, key) {\n  return ({}).hasOwnProperty.call(obj, key);\n}\n\n// Returns those elements of `a` for which `cb(a)` returns truthy\nfunction filter(a, cb) {\n  const n = [];\n  each(a, function(v) {\n    if (cb(v)) {\n      n.push(v);\n    }\n  });\n  return n;\n}\n\nfunction isEmptyObject(obj) {\n  for (const key in obj) {\n    if (has(obj, key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction stringifySrcset(parsedSrcset) {\n  return parsedSrcset.map(function(part) {\n    if (!part.url) {\n      throw new Error('URL missing');\n    }\n\n    return (\n      part.url +\n      (part.w ? ` ${part.w}w` : '') +\n      (part.h ? ` ${part.h}h` : '') +\n      (part.d ? ` ${part.d}x` : '')\n    );\n  }).join(', ');\n}\n\nmodule.exports = sanitizeHtml;\n\n// A valid attribute name.\n// We use a tolerant definition based on the set of strings defined by\n// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state\n// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .\n// The characters accepted are ones which can be appended to the attribute\n// name buffer without triggering a parse error:\n//   * unexpected-equals-sign-before-attribute-name\n//   * unexpected-null-character\n//   * unexpected-character-in-attribute-name\n// We exclude the empty string because it's impossible to get to the after\n// attribute name state with an empty attribute name buffer.\nconst VALID_HTML_ATTRIBUTE_NAME = /^[^\\0\\t\\n\\f\\r /<=>]+$/;\n\n// Ignore the _recursing flag; it's there for recursive\n// invocation as a guard against this exploit:\n// https://github.com/fb55/htmlparser2/issues/105\n\nfunction sanitizeHtml(html, options, _recursing) {\n  if (html == null) {\n    return '';\n  }\n  if (typeof html === 'number') {\n    html = html.toString();\n  }\n\n  let result = '';\n  // Used for hot swapping the result variable with an empty string in order to \"capture\" the text written to it.\n  let tempResult = '';\n\n  function Frame(tag, attribs) {\n    const that = this;\n    this.tag = tag;\n    this.attribs = attribs || {};\n    this.tagPosition = result.length;\n    this.text = ''; // Node inner text\n    this.mediaChildren = [];\n\n    this.updateParentNodeText = function() {\n      if (stack.length) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.text += that.text;\n      }\n    };\n\n    this.updateParentNodeMediaChildren = function() {\n      if (stack.length && mediaTags.includes(this.tag)) {\n        const parentFrame = stack[stack.length - 1];\n        parentFrame.mediaChildren.push(this.tag);\n      }\n    };\n  }\n\n  options = Object.assign({}, sanitizeHtml.defaults, options);\n  options.parser = Object.assign({}, htmlParserDefaults, options.parser);\n\n  // vulnerableTags\n  vulnerableTags.forEach(function (tag) {\n    if (\n      options.allowedTags !== false && (options.allowedTags || []).indexOf(tag) > -1 &&\n      !options.allowVulnerableTags\n    ) {\n      console.warn(`\\n\\n⚠️ Your \\`allowedTags\\` option includes, \\`${tag}\\`, which is inherently\\nvulnerable to XSS attacks. Please remove it from \\`allowedTags\\`.\\nOr, to disable this warning, add the \\`allowVulnerableTags\\` option\\nand ensure you are accounting for this risk.\\n\\n`);\n    }\n  });\n\n  // Tags that contain something other than HTML, or where discarding\n  // the text when the tag is disallowed makes sense for other reasons.\n  // If we are not allowing these tags, we should drop their content too.\n  // For other tags you would drop the tag but keep its content.\n  const nonTextTagsArray = options.nonTextTags || [\n    'script',\n    'style',\n    'textarea',\n    'option'\n  ];\n  let allowedAttributesMap;\n  let allowedAttributesGlobMap;\n  if (options.allowedAttributes) {\n    allowedAttributesMap = {};\n    allowedAttributesGlobMap = {};\n    each(options.allowedAttributes, function(attributes, tag) {\n      allowedAttributesMap[tag] = [];\n      const globRegex = [];\n      attributes.forEach(function(obj) {\n        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n          globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n        } else {\n          allowedAttributesMap[tag].push(obj);\n        }\n      });\n      if (globRegex.length) {\n        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n      }\n    });\n  }\n  const allowedClassesMap = {};\n  const allowedClassesGlobMap = {};\n  const allowedClassesRegexMap = {};\n  each(options.allowedClasses, function(classes, tag) {\n    // Implicitly allows the class attribute\n    if (allowedAttributesMap) {\n      if (!has(allowedAttributesMap, tag)) {\n        allowedAttributesMap[tag] = [];\n      }\n      allowedAttributesMap[tag].push('class');\n    }\n\n    allowedClassesMap[tag] = [];\n    allowedClassesRegexMap[tag] = [];\n    const globRegex = [];\n    classes.forEach(function(obj) {\n      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {\n        globRegex.push(escapeStringRegexp(obj).replace(/\\\\\\*/g, '.*'));\n      } else if (obj instanceof RegExp) {\n        allowedClassesRegexMap[tag].push(obj);\n      } else {\n        allowedClassesMap[tag].push(obj);\n      }\n    });\n    if (globRegex.length) {\n      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');\n    }\n  });\n\n  const transformTagsMap = {};\n  let transformTagsAll;\n  each(options.transformTags, function(transform, tag) {\n    let transFun;\n    if (typeof transform === 'function') {\n      transFun = transform;\n    } else if (typeof transform === 'string') {\n      transFun = sanitizeHtml.simpleTransform(transform);\n    }\n    if (tag === '*') {\n      transformTagsAll = transFun;\n    } else {\n      transformTagsMap[tag] = transFun;\n    }\n  });\n\n  let depth;\n  let stack;\n  let skipMap;\n  let transformMap;\n  let skipText;\n  let skipTextDepth;\n  let addedText = false;\n\n  initializeState();\n\n  const parser = new htmlparser.Parser({\n    onopentag: function(name, attribs) {\n      // If `enforceHtmlBoundary` is `true` and this has found the opening\n      // `html` tag, reset the state.\n      if (options.enforceHtmlBoundary && name === 'html') {\n        initializeState();\n      }\n\n      if (skipText) {\n        skipTextDepth++;\n        return;\n      }\n      const frame = new Frame(name, attribs);\n      stack.push(frame);\n\n      let skip = false;\n      const hasText = !!frame.text;\n      let transformedTag;\n      if (has(transformTagsMap, name)) {\n        transformedTag = transformTagsMap[name](name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n\n        if (transformedTag.text !== undefined) {\n          frame.innerText = transformedTag.text;\n        }\n\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n      if (transformTagsAll) {\n        transformedTag = transformTagsAll(name, attribs);\n\n        frame.attribs = attribs = transformedTag.attribs;\n        if (name !== transformedTag.tagName) {\n          frame.name = name = transformedTag.tagName;\n          transformMap[depth] = transformedTag.tagName;\n        }\n      }\n\n      if ((options.allowedTags !== false && (options.allowedTags || []).indexOf(name) === -1) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {\n        skip = true;\n        skipMap[depth] = true;\n        if (options.disallowedTagsMode === 'discard') {\n          if (nonTextTagsArray.indexOf(name) !== -1) {\n            skipText = true;\n            skipTextDepth = 1;\n          }\n        }\n        skipMap[depth] = true;\n      }\n      depth++;\n      if (skip) {\n        if (options.disallowedTagsMode === 'discard') {\n          // We want the contents but not this tag\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n      result += '<' + name;\n\n      if (name === 'script') {\n        if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n          frame.innerText = '';\n        }\n      }\n\n      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {\n        each(attribs, function(value, a) {\n          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {\n            // This prevents part of an attribute name in the output from being\n            // interpreted as the end of an attribute, or end of a tag.\n            delete frame.attribs[a];\n            return;\n          }\n          // check allowedAttributesMap for the element and attribute and modify the value\n          // as necessary if there are specific values defined.\n          let passedAllowedAttributesMapCheck = false;\n          if (!allowedAttributesMap ||\n            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||\n            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||\n            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||\n            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {\n            passedAllowedAttributesMapCheck = true;\n          } else if (allowedAttributesMap && allowedAttributesMap[name]) {\n            for (const o of allowedAttributesMap[name]) {\n              if (isPlainObject(o) && o.name && (o.name === a)) {\n                passedAllowedAttributesMapCheck = true;\n                let newValue = '';\n                if (o.multiple === true) {\n                  // verify the values that are allowed\n                  const splitStrArray = value.split(' ');\n                  for (const s of splitStrArray) {\n                    if (o.values.indexOf(s) !== -1) {\n                      if (newValue === '') {\n                        newValue = s;\n                      } else {\n                        newValue += ' ' + s;\n                      }\n                    }\n                  }\n                } else if (o.values.indexOf(value) >= 0) {\n                  // verified an allowed value matches the entire attribute value\n                  newValue = value;\n                }\n                value = newValue;\n              }\n            }\n          }\n          if (passedAllowedAttributesMapCheck) {\n            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {\n              if (naughtyHref(name, value)) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'script' && a === 'src') {\n\n              let allowed = true;\n\n              try {\n                const parsed = parseUrl(value);\n\n                if (options.allowedScriptHostnames || options.allowedScriptDomains) {\n                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                allowed = false;\n              }\n\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n\n            if (name === 'iframe' && a === 'src') {\n              let allowed = true;\n              try {\n                const parsed = parseUrl(value);\n\n                if (parsed.isRelativeUrl) {\n                  // default value of allowIframeRelativeUrls is true\n                  // unless allowedIframeHostnames or allowedIframeDomains specified\n                  allowed = has(options, 'allowIframeRelativeUrls')\n                    ? options.allowIframeRelativeUrls\n                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);\n                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {\n                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {\n                    return hostname === parsed.url.hostname;\n                  });\n                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {\n                    return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);\n                  });\n                  allowed = allowedHostname || allowedDomain;\n                }\n              } catch (e) {\n                // Unparseable iframe src\n                allowed = false;\n              }\n              if (!allowed) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'srcset') {\n              try {\n                let parsed = parseSrcset(value);\n                parsed.forEach(function(value) {\n                  if (naughtyHref('srcset', value.url)) {\n                    value.evil = true;\n                  }\n                });\n                parsed = filter(parsed, function(v) {\n                  return !v.evil;\n                });\n                if (!parsed.length) {\n                  delete frame.attribs[a];\n                  return;\n                } else {\n                  value = stringifySrcset(filter(parsed, function(v) {\n                    return !v.evil;\n                  }));\n                  frame.attribs[a] = value;\n                }\n              } catch (e) {\n                // Unparseable srcset\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'class') {\n              const allowedSpecificClasses = allowedClassesMap[name];\n              const allowedWildcardClasses = allowedClassesMap['*'];\n              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];\n              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];\n              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];\n              const allowedClassesGlobs = [\n                allowedSpecificClassesGlob,\n                allowedWildcardClassesGlob\n              ]\n                .concat(allowedSpecificClassesRegex)\n                .filter(function (t) {\n                  return t;\n                });\n              if (allowedSpecificClasses && allowedWildcardClasses) {\n                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);\n              } else {\n                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);\n              }\n              if (!value.length) {\n                delete frame.attribs[a];\n                return;\n              }\n            }\n            if (a === 'style') {\n              if (options.parseStyleAttributes) {\n                try {\n                  const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');\n                  const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);\n\n                  value = stringifyStyleAttributes(filteredAST);\n\n                  if (value.length === 0) {\n                    delete frame.attribs[a];\n                    return;\n                  }\n                } catch (e) {\n                  console.warn('Failed to parse \"' + name + ' {' + value + '}' + '\", If you\\'re running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547');\n                  delete frame.attribs[a];\n                  return;\n                }\n              } else if (options.allowedStyles) {\n                throw new Error('allowedStyles option cannot be used together with parseStyleAttributes: false.');\n              }\n            }\n            result += ' ' + a;\n            if (value && value.length) {\n              result += '=\"' + escapeHtml(value, true) + '\"';\n            }\n          } else {\n            delete frame.attribs[a];\n          }\n        });\n      }\n      if (options.selfClosing.indexOf(name) !== -1) {\n        result += ' />';\n      } else {\n        result += '>';\n        if (frame.innerText && !hasText && !options.textFilter) {\n          result += escapeHtml(frame.innerText);\n          addedText = true;\n        }\n      }\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n    },\n    ontext: function(text) {\n      if (skipText) {\n        return;\n      }\n      const lastFrame = stack[stack.length - 1];\n      let tag;\n\n      if (lastFrame) {\n        tag = lastFrame.tag;\n        // If inner text was set by transform function then let's use it\n        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;\n      }\n\n      if (options.disallowedTagsMode === 'discard' && ((tag === 'script') || (tag === 'style'))) {\n        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing\n        // script tags is, by definition, game over for XSS protection, so if that's\n        // your concern, don't allow them. The same is essentially true for style tags\n        // which have their own collection of XSS vectors.\n        result += text;\n      } else {\n        const escaped = escapeHtml(text, false);\n        if (options.textFilter && !addedText) {\n          result += options.textFilter(escaped, tag);\n        } else if (!addedText) {\n          result += escaped;\n        }\n      }\n      if (stack.length) {\n        const frame = stack[stack.length - 1];\n        frame.text += text;\n      }\n    },\n    onclosetag: function(name) {\n\n      if (skipText) {\n        skipTextDepth--;\n        if (!skipTextDepth) {\n          skipText = false;\n        } else {\n          return;\n        }\n      }\n\n      const frame = stack.pop();\n      if (!frame) {\n        // Do not crash on bad markup\n        return;\n      }\n\n      if (frame.tag !== name) {\n        // Another case of bad markup.\n        // Push to stack, so that it will be used in future closing tags.\n        stack.push(frame);\n        return;\n      }\n\n      skipText = options.enforceHtmlBoundary ? name === 'html' : false;\n      depth--;\n      const skip = skipMap[depth];\n      if (skip) {\n        delete skipMap[depth];\n        if (options.disallowedTagsMode === 'discard') {\n          frame.updateParentNodeText();\n          return;\n        }\n        tempResult = result;\n        result = '';\n      }\n\n      if (transformMap[depth]) {\n        name = transformMap[depth];\n        delete transformMap[depth];\n      }\n\n      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {\n        result = result.substr(0, frame.tagPosition);\n        return;\n      }\n\n      frame.updateParentNodeMediaChildren();\n      frame.updateParentNodeText();\n\n      if (options.selfClosing.indexOf(name) !== -1) {\n        // Already output />\n        if (skip) {\n          result = tempResult;\n          tempResult = '';\n        }\n        return;\n      }\n\n      result += '</' + name + '>';\n      if (skip) {\n        result = tempResult + escapeHtml(result);\n        tempResult = '';\n      }\n      addedText = false;\n    }\n  }, options.parser);\n  parser.write(html);\n  parser.end();\n\n  return result;\n\n  function initializeState() {\n    result = '';\n    depth = 0;\n    stack = [];\n    skipMap = {};\n    transformMap = {};\n    skipText = false;\n    skipTextDepth = 0;\n  }\n\n  function escapeHtml(s, quote) {\n    if (typeof (s) !== 'string') {\n      s = s + '';\n    }\n    if (options.parser.decodeEntities) {\n      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n      if (quote) {\n        s = s.replace(/\"/g, '&quot;');\n      }\n    }\n    // TODO: this is inadequate because it will pass `&0;`. This approach\n    // will not work, each & must be considered with regard to whether it\n    // is followed by a 100% syntactically valid entity or not, and escaped\n    // if it is not. If this bothers you, don't set parser.decodeEntities\n    // to false. (The default is true.)\n    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n    if (quote) {\n      s = s.replace(/\"/g, '&quot;');\n    }\n    return s;\n  }\n\n  function naughtyHref(name, href) {\n    // Browsers ignore character codes of 32 (space) and below in a surprising\n    // number of situations. Start reading here:\n    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab\n    // eslint-disable-next-line no-control-regex\n    href = href.replace(/[\\x00-\\x20]+/g, '');\n    // Clobber any comments in URLs, which the browser might\n    // interpret inside an XML data island, allowing\n    // a javascript: URL to be snuck through\n    while (true) {\n      const firstIndex = href.indexOf('<!--');\n      if (firstIndex === -1) {\n        break;\n      }\n      const lastIndex = href.indexOf('-->', firstIndex + 4);\n      if (lastIndex === -1) {\n        break;\n      }\n      href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);\n    }\n    // Case insensitive so we don't get faked out by JAVASCRIPT #1\n    // Allow more characters after the first so we don't get faked\n    // out by certain schemes browsers accept\n    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\\-+]*):/);\n    if (!matches) {\n      // Protocol-relative URL starting with any combination of '/' and '\\'\n      if (href.match(/^[/\\\\]{2}/)) {\n        return !options.allowProtocolRelative;\n      }\n\n      // No scheme\n      return false;\n    }\n    const scheme = matches[1].toLowerCase();\n\n    if (has(options.allowedSchemesByTag, name)) {\n      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;\n    }\n\n    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;\n  }\n\n  function parseUrl(value) {\n    value = value.replace(/^(\\w+:)?\\s*[\\\\/]\\s*[\\\\/]/, '$1//');\n    if (value.startsWith('relative:')) {\n      // An attempt to exploit our workaround for base URLs being\n      // mandatory for relative URL validation in the WHATWG\n      // URL parser, reject it\n      throw new Error('relative: exploit attempt');\n    }\n    // naughtyHref is in charge of whether protocol relative URLs\n    // are cool. Here we are concerned just with allowed hostnames and\n    // whether to allow relative URLs.\n    //\n    // Build a placeholder \"base URL\" against which any reasonable\n    // relative URL may be parsed successfully\n    let base = 'relative://relative-site';\n    for (let i = 0; (i < 100); i++) {\n      base += `/${i}`;\n    }\n\n    const parsed = new URL(value, base);\n\n    const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';\n    return {\n      isRelativeUrl,\n      url: parsed\n    };\n  }\n  /**\n   * Filters user input css properties by allowlisted regex attributes.\n   * Modifies the abstractSyntaxTree object.\n   *\n   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.\n   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.\n   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).\n   * @return {object}                    - The modified tree.\n   */\n  function filterCss(abstractSyntaxTree, allowedStyles) {\n    if (!allowedStyles) {\n      return abstractSyntaxTree;\n    }\n\n    const astRules = abstractSyntaxTree.nodes[0];\n    let selectedRule;\n\n    // Merge global and tag-specific styles into new AST.\n    if (allowedStyles[astRules.selector] && allowedStyles['*']) {\n      selectedRule = deepmerge(\n        allowedStyles[astRules.selector],\n        allowedStyles['*']\n      );\n    } else {\n      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];\n    }\n\n    if (selectedRule) {\n      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);\n    }\n\n    return abstractSyntaxTree;\n  }\n\n  /**\n   * Extracts the style attributes from an AbstractSyntaxTree and formats those\n   * values in the inline style attribute format.\n   *\n   * @param  {AbstractSyntaxTree} filteredAST\n   * @return {string}             - Example: \"color:yellow;text-align:center !important;font-family:helvetica;\"\n   */\n  function stringifyStyleAttributes(filteredAST) {\n    return filteredAST.nodes[0].nodes\n      .reduce(function(extractedAttributes, attrObject) {\n        extractedAttributes.push(\n          `${attrObject.prop}:${attrObject.value}${attrObject.important ? ' !important' : ''}`\n        );\n        return extractedAttributes;\n      }, [])\n      .join(';');\n  }\n\n  /**\n    * Filters the existing attributes for the given property. Discards any attributes\n    * which don't match the allowlist.\n    *\n    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }\n    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.\n    * @param  {object} attributeObject          - Object representing the current css property.\n    * @property {string} attributeObject.type   - Typically 'declaration'.\n    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.\n    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.\n    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects\n    */\n  function filterDeclarations(selectedRule) {\n    return function (allowedDeclarationsList, attributeObject) {\n      // If this property is allowlisted...\n      if (has(selectedRule, attributeObject.prop)) {\n        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {\n          return regularExpression.test(attributeObject.value);\n        });\n\n        if (matchesRegex) {\n          allowedDeclarationsList.push(attributeObject);\n        }\n      }\n      return allowedDeclarationsList;\n    };\n  }\n\n  function filterClasses(classes, allowed, allowedGlobs) {\n    if (!allowed) {\n      // The class attribute is allowed without filtering on this tag\n      return classes;\n    }\n    classes = classes.split(/\\s+/);\n    return classes.filter(function(clss) {\n      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {\n        return glob.test(clss);\n      });\n    }).join(' ');\n  }\n}\n\n// Defaults are accessible to you so that you can use them as a starting point\n// programmatically if you wish\n\nconst htmlParserDefaults = {\n  decodeEntities: true\n};\nsanitizeHtml.defaults = {\n  allowedTags: [\n    // Sections derived from MDN element categories and limited to the more\n    // benign categories.\n    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n    // Content sectioning\n    'address', 'article', 'aside', 'footer', 'header',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',\n    'main', 'nav', 'section',\n    // Text content\n    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',\n    'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',\n    // Inline text semantics\n    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',\n    'em', 'i', 'kbd', 'mark', 'q',\n    'rb', 'rp', 'rt', 'rtc', 'ruby',\n    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',\n    // Table content\n    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',\n    'thead', 'tr'\n  ],\n  disallowedTagsMode: 'discard',\n  allowedAttributes: {\n    a: [ 'href', 'name', 'target' ],\n    // We don't currently allow img itself by default, but\n    // these attributes would make sense if we did.\n    img: [ 'src', 'srcset', 'alt', 'title', 'width', 'height', 'loading' ]\n  },\n  // Lots of these won't come up by default because we don't allow them\n  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],\n  // URL schemes we permit\n  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],\n  allowedSchemesByTag: {},\n  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],\n  allowProtocolRelative: true,\n  enforceHtmlBoundary: false,\n  parseStyleAttributes: true\n};\n\nsanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {\n  merge = (merge === undefined) ? true : merge;\n  newAttribs = newAttribs || {};\n\n  return function(tagName, attribs) {\n    let attrib;\n    if (merge) {\n      for (attrib in newAttribs) {\n        attribs[attrib] = newAttribs[attrib];\n      }\n    } else {\n      attribs = newAttribs;\n    }\n\n    return {\n      tagName: newTagName,\n      attribs: attribs\n    };\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}